/**
 * generated by Xtext 2.14.0
 */
package com.zazuko.experimental.rmdsl.generator;

import com.google.common.collect.Iterators;
import com.zazuko.experimental.rmdsl.rdfMapping.LogicalSource;
import com.zazuko.experimental.rmdsl.rdfMapping.Mapping;
import com.zazuko.experimental.rmdsl.rdfMapping.PredicateObjectMapping;
import com.zazuko.experimental.rmdsl.rdfMapping.RdfClass;
import com.zazuko.experimental.rmdsl.rdfMapping.RdfProperty;
import com.zazuko.experimental.rmdsl.rdfMapping.SourceGroup;
import com.zazuko.experimental.rmdsl.rdfMapping.SourceType;
import com.zazuko.experimental.rmdsl.rdfMapping.SubjectTypeMapping;
import com.zazuko.experimental.rmdsl.rdfMapping.Vocabulary;
import java.text.MessageFormat;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class RdfMappingGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    fsa.generateFile("rml.ttl", this.rml(resource));
    fsa.generateFile("r2rml.ttl", this.r2rml(resource));
  }
  
  public String rml(final Resource resource) {
    CharSequence _prefixes = this.prefixes();
    final Function1<Mapping, CharSequence> _function = (Mapping it) -> {
      return this.rmlTriplesMap(it);
    };
    String _join = IteratorExtensions.join(IteratorExtensions.<Mapping, CharSequence>map(Iterators.<Mapping>filter(resource.getAllContents(), Mapping.class), _function), "\n");
    return (_prefixes + _join);
  }
  
  public String r2rml(final Resource resource) {
    CharSequence _prefixes = this.prefixes();
    final Function1<Mapping, CharSequence> _function = (Mapping it) -> {
      return this.r2rmlTriplesMap(it);
    };
    String _join = IteratorExtensions.join(IteratorExtensions.<Mapping, CharSequence>map(Iterators.<Mapping>filter(resource.getAllContents(), Mapping.class), _function), "\n");
    return (_prefixes + _join);
  }
  
  public CharSequence prefixes() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("PREFIX rr: <http://www.w3.org/ns/r2rml#>.");
    _builder.newLine();
    _builder.append("PREFIX rml: <http://semweb.mmlab.be/ns/rml#>.");
    _builder.newLine();
    _builder.append("PREFIX ql: <http://semweb.mmlab.be/ns/ql#>.");
    _builder.newLine();
    _builder.newLine();
    _builder.append("// TODO: insert prefixes from vocabularies in-use");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence rmlTriplesMap(final Mapping m) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("<#");
    String _name = m.getName();
    _builder.append(_name);
    _builder.append(">");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("rml:logicalSource [  ");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("rml:source \"");
    String _sourceResolved = this.sourceResolved(m.getSource());
    _builder.append(_sourceResolved, "\t\t");
    _builder.append("\" ;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("rml:referenceFormulation ");
    SourceType _typeResolved = this.typeResolved(m.getSource());
    String _referenceFormulation = null;
    if (_typeResolved!=null) {
      _referenceFormulation=_typeResolved.getReferenceFormulation();
    }
    _builder.append(_referenceFormulation, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("];");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    CharSequence _subjectMap = this.subjectMap(m);
    _builder.append(_subjectMap, "\t");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    {
      EList<PredicateObjectMapping> _poMappings = m.getPoMappings();
      for(final PredicateObjectMapping pom : _poMappings) {
        _builder.append("\t");
        CharSequence _rmlPredicateObjectMap = this.rmlPredicateObjectMap(pom);
        _builder.append(_rmlPredicateObjectMap, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence r2rmlTriplesMap(final Mapping m) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("<#");
    String _name = m.getName();
    _builder.append(_name);
    _builder.append(">");
    _builder.newLineIfNotEmpty();
    _builder.append("    ");
    _builder.append("rr:logicalTable [ rr:tableName \"");
    String _sourceResolved = this.sourceResolved(m.getSource());
    _builder.append(_sourceResolved, "    ");
    _builder.append("\" ];");
    _builder.newLineIfNotEmpty();
    _builder.append("    ");
    CharSequence _subjectMap = this.subjectMap(m);
    _builder.append(_subjectMap, "    ");
    _builder.newLineIfNotEmpty();
    _builder.append("    ");
    _builder.newLine();
    {
      EList<PredicateObjectMapping> _poMappings = m.getPoMappings();
      for(final PredicateObjectMapping pom : _poMappings) {
        _builder.append("    ");
        CharSequence _r2rmlPredicateObjectMap = this.r2rmlPredicateObjectMap(pom);
        _builder.append(_r2rmlPredicateObjectMap, "    ");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence subjectMap(final Mapping m) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("rr:subjectMap [");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("rr:template \"");
    String _subjectIri = this.subjectIri(m);
    _builder.append(_subjectIri, "\t");
    _builder.append("\";");
    _builder.newLineIfNotEmpty();
    {
      EList<SubjectTypeMapping> _subjectTypeMappings = m.getSubjectTypeMappings();
      for(final SubjectTypeMapping stm : _subjectTypeMappings) {
        _builder.append("\t");
        _builder.append("rr:class ");
        String _label = this.vocabulary(stm.getType()).getPrefix().getLabel();
        _builder.append(_label, "\t");
        String _name = stm.getType().getName();
        _builder.append(_name, "\t");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("];");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence rmlPredicateObjectMap(final PredicateObjectMapping pom) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("rr:predicateObjectMap [");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("rr:predicate ");
    String _label = this.vocabulary(pom.getProperty()).getPrefix().getLabel();
    _builder.append(_label, "\t");
    String _name = pom.getProperty().getName();
    _builder.append(_name, "\t");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("rr:objectMap [");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("rml:reference \"");
    String _value = pom.getReference().getValue();
    _builder.append(_value, "\t\t");
    _builder.append("\";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("// TODO: rr:datatype xsd:FOO");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("];");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence r2rmlPredicateObjectMap(final PredicateObjectMapping pom) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("rr:predicateObjectMap [");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("rr:predicate ");
    String _label = this.vocabulary(pom.getProperty()).getPrefix().getLabel();
    _builder.append(_label, "\t");
    String _name = pom.getProperty().getName();
    _builder.append(_name, "\t");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("rr:objectMap [");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("rr:column \"");
    String _value = pom.getReference().getValue();
    _builder.append(_value, "\t\t");
    _builder.append("\";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("];");
    _builder.newLine();
    return _builder;
  }
  
  public String subjectIri(final Mapping m) {
    String _pattern = m.getPattern();
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("{");
    String _value = m.getReference().getValue();
    _builder.append(_value);
    _builder.append("}");
    return MessageFormat.format(_pattern, _builder);
  }
  
  public String sourceResolved(final LogicalSource it) {
    String _xifexpression = null;
    String _source = it.getSource();
    boolean _tripleNotEquals = (_source != null);
    if (_tripleNotEquals) {
      _xifexpression = it.getSource();
    } else {
      EObject _eContainer = it.eContainer();
      String _source_1 = null;
      if (((SourceGroup) _eContainer)!=null) {
        _source_1=((SourceGroup) _eContainer).getSource();
      }
      _xifexpression = _source_1;
    }
    return _xifexpression;
  }
  
  public SourceType typeResolved(final LogicalSource it) {
    SourceType _xifexpression = null;
    SourceType _type = it.getType();
    boolean _tripleNotEquals = (_type != null);
    if (_tripleNotEquals) {
      _xifexpression = it.getType();
    } else {
      EObject _eContainer = it.eContainer();
      SourceType _type_1 = null;
      if (((SourceGroup) _eContainer)!=null) {
        _type_1=((SourceGroup) _eContainer).getType();
      }
      _xifexpression = _type_1;
    }
    return _xifexpression;
  }
  
  public Vocabulary vocabulary(final RdfClass it) {
    EObject _eContainer = it.eContainer();
    return ((Vocabulary) _eContainer);
  }
  
  public Vocabulary vocabulary(final RdfProperty it) {
    EObject _eContainer = it.eContainer();
    return ((Vocabulary) _eContainer);
  }
}
