/*
 * generated by Xtext 2.14.0
 */
package com.zazuko.experimental.rmdsl.generator

import com.zazuko.experimental.rmdsl.rdfMapping.LinkedResourceTerm
import com.zazuko.experimental.rmdsl.rdfMapping.Mapping
import com.zazuko.experimental.rmdsl.rdfMapping.PredicateObjectMapping
import com.zazuko.experimental.rmdsl.rdfMapping.ReferenceValuedTerm
import com.zazuko.experimental.rmdsl.rdfMapping.TemplateValuedTerm
import com.zazuko.experimental.rmdsl.rdfMapping.ValuedTerm
import java.text.MessageFormat
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension com.zazuko.experimental.rmdsl.generator.ModelAccess.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class RdfMappingGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val Iterable<Mapping> mappings = resource.allContents.filter(Mapping).toList
		fsa.generateFile('rml.ttl', rml(mappings))
		fsa.generateFile('r2rml.ttl', r2rml(mappings))
	}
	
	def rml(Iterable<Mapping> mappings) {
		mappings.prefixes +
		mappings
			.map[rmlTriplesMap]
			.join('\n')
	}
	
	def r2rml(Iterable<Mapping> mappings) {
		mappings.prefixes +
		mappings
			.map[r2rmlTriplesMap]
			.join('\n')
	}
	
	def prefixes(Iterable<Mapping> mappings) '''
		PREFIX rr: <http://www.w3.org/ns/r2rml#>
		PREFIX rml: <http://semweb.mmlab.be/ns/rml#>
		PREFIX ql: <http://semweb.mmlab.be/ns/ql#>
		«FOR voc:mappings.vocabulariesUsed.inDeterministicOrder»
			PREFIX «voc.prefix.label» <«voc.prefix.iri»>
		«ENDFOR»
		
		# debug output ..
		«FOR m:mappings»
			# «m.name» 
		«ENDFOR»

	'''
	
	def rmlTriplesMap(Mapping m) '''
		<#«m.name»>
			rml:logicalSource [  
				rml:source "«m.source.sourceResolved»" ;
««« TODO        rml:iterator "/transport/bus";
				rml:referenceFormulation «m.source.typeResolved?.referenceFormulation»
			];

			«m.subjectMap()»
		
			«FOR pom : m.poMappings»
				«pom.rmlPredicateObjectMap»
			«ENDFOR»
	'''
	
	def r2rmlTriplesMap(Mapping m) '''
		<#«m.name»>
		    rr:logicalTable [ rr:tableName "«m.source.sourceResolved»" ];
		    «m.subjectMap()»
		    
		    «FOR pom : m.poMappings SEPARATOR ";" AFTER "."»
		    	«pom.r2rmlPredicateObjectMap»
			«ENDFOR»
	'''
	
	def subjectMap(Mapping m) '''
		rr:subjectMap [
			rr:template "«m.subjectIri»";
			«FOR stm : m.subjectTypeMappings»
				rr:class «stm.type.vocabulary.prefix.label»«stm.type.name» ;
			«ENDFOR»	
		];
	'''
	
	// TODO: refactoring pending, to support all term variations for RML as well	
	def rmlPredicateObjectMap(PredicateObjectMapping pom) '''
		rr:predicateObjectMap [
			rr:predicate «pom.property.vocabulary.prefix.label»«pom.property.name» ;
			rr:objectMap [
«««				rml:reference "«(pom.term as ReferenceValuedTerm).reference.valueResolved»" ;
«««				«(pom.term as ReferenceValuedTerm).termMapAnnex»
			].
		];
	'''
	
	def r2rmlPredicateObjectMap(PredicateObjectMapping pom) '''
		rr:predicateObjectMap [
			rr:predicate «pom.property.vocabulary.prefix.label»«pom.property.name» ;
			rr:objectMap [
				«pom.term.objectTermMap»
			];
		]
	'''
	
	def dispatch objectTermMap(ValuedTerm it) '''
		# TODO: implementation missing for «class.name»
	'''
	
	def dispatch objectTermMap(ReferenceValuedTerm it) '''
		rr:column "«reference.valueResolved»" ;
		«termMapAnnex»
	'''
	
	def dispatch objectTermMap(TemplateValuedTerm it) '''
		rr:template "«toTemplateString»" ;
	'''
	
	def dispatch objectTermMap(LinkedResourceTerm it) '''
		rr:template "«toTemplateString»" ;
	'''
	
	def termMapAnnex(ReferenceValuedTerm it) '''
		«IF languageTag !== null»
			rr:language "«languageTag.name»" ;
		«ELSEIF datatype !== null»
			rr:datatype «datatype.prefix.label»«datatype.name» ;
		«ENDIF»		
	'''
	
	def subjectIri(Mapping m) {		
		MessageFormat.format(m.pattern, '''{«m.reference.valueResolved»}''');
	}
	
	def toTemplateString(TemplateValuedTerm it) {		
		MessageFormat.format(pattern, '''{«reference.valueResolved»}''');
	}
	
	def toTemplateString(LinkedResourceTerm it) {		
		MessageFormat.format(mapping.pattern, '''{«reference.valueResolved»}''');
	}	
	
}
